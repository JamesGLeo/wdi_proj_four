<!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8 />
  <title>Spot Spots!</title>
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

  <!-- Stylesheet -->
  <link rel="stylesheet" href="/css/styles.css">
  
  <!--MapBox-->
  <script src='https://api.tiles.mapbox.com/mapbox.js/v2.1.4/mapbox.js'></script>
  <link href='https://api.tiles.mapbox.com/mapbox.js/v2.1.4/mapbox.css' rel='stylesheet' />

  <!-- Libraries:  Jquery -->
  <script src='/js/jquery.js'></script>

  <!--App-->
  <script src='/js/app.js'></script>
</head>

<body>
<!-- Leaflet Plugins: Omnivore for geoJSON parsing-->
<script src='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-omnivore/v0.2.0/leaflet-omnivore.min.js'></script>

<!-- Leaflet Plugins: minimap for overwatch views-->
<script src='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-minimap/v1.0.0/Control.MiniMap.js'></script>
<link href='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-minimap/v1.0.0/Control.MiniMap.css' rel='stylesheet' />


<div id='map'></div>

<div id='loading'></div>

<a href='#' id='geolocate' class='ui-button'><strong>+</strong></a>

<script>

  // Map created with Mapbox
  L.mapbox.accessToken = 'pk.eyJ1IjoiamFtZXNsaXVtYXBzIiwiYSI6InhLTDh6eUEifQ.mpBGKMabJ51bqz0kktgoEA';
  var geolocate = document.getElementById('geolocate');
  var map = L.mapbox.map('map', 'jamesliumaps.kfii0fpm')
          .on('ready', function() {
            // Minimap
            new L.Control.MiniMap(L.mapbox.tileLayer('jamesliumaps.kfii0fpm'))
                    .addTo(map);
          });

  var jsonData = "test_data.geojson"

  var featureLayer = L.mapbox.featureLayer()
    .loadURL(jsonData)
    .on('ready', function(layer) {
        // An example of customizing marker styles based on an attribute.
        // In this case, the data, a CSV file, has a column called 'state'
        // with values referring to states. Your data might have different
        // values, so adjust to fit.
        this.eachLayer(function(marker) {
            if (marker.toGeoJSON()) {
                // The argument to L.mapbox.marker.icon is based on the
                // simplestyle-spec: see that specification for a full
                // description of options.
                marker.setIcon(L.mapbox.marker.icon({
                    'marker-color': '#ff8888',
                    'marker-size': 'small',
                    'iconUrl': '../images/red.png'
                }));
            } 
        });
    })
    .addTo(map);


var userLayer = L.mapbox.featureLayer().addTo(map);

// This uses the HTML5 geolocation API, which is available on
// most mobile browsers and modern browsers, but not in Internet Explorer
//
// See this chart of compatibility for details:
// http://caniuse.com/#feat=geolocation
if (!navigator.geolocation) {
    geolocate.innerHTML = 'Geolocation is not available';
} else {
    geolocate.onclick = function (e) {
        e.preventDefault();
        e.stopPropagation();
        map.locate();
    };
}

// Once we've got a position, zoom and center the map
// on it, and add a single marker.
map.on('locationfound', function(e) {
    map.fitBounds(e.bounds);

    userLayer.setGeoJSON({
        type: 'Feature',
        geometry: {
            type: 'Point',
            coordinates: [e.latlng.lng, e.latlng.lat]
        },
        properties: {
            'title': 'User Located',
            'marker-color': '#51a3c9',
            'marker-size': 'large',
            'marker-symbol': 'car'
        }
    });
});

// If the user chooses not to allow their location
// to be shared, display an error message.
map.on('locationerror', function() {
    geolocate.innerHTML = 'Position could not be found';
});

  // parkingMap(map, jsonData);



//  var svg = d3.select(map.getPanes()
//              .overlayPane)
//              .append("svg"),
//      g =  svg.append("g")
//              .attr("class", "leaflet-zoom-hide");
//
//  jsonData = //whatever we're passing in
//  d3.json(jsonData, function(collection) {
//    var transform = d3.geo
//                      .transform({point: projectPoint}),
//             path = d3.geo
//                      .path()
//                      .projection(transform);
//
//    var feature = g.selectAll("path")
//                   .data(collection.features)
//                   .enter()
//                   .append("path");
//
//    map.on("viewreset", reset);
//
//    reset();
//
//// Reposition the SVG to cover the features.
//    function reset() {
//      var bounds = path.bounds(collection),
//          topLeft = bounds[0],
//          bottomRight = bounds[1];
//
//      svg .attr("width", bottomRight[0] - topLeft[0])
//          .attr("height", bottomRight[1] - topLeft[1])
//          .style("left", topLeft[0] + "px")
//          .style("top", topLeft[1] + "px");
//
//        g .attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");
//
//      feature.attr("d", path);
//    }
//
//// Use Leaflet to implement a D3 geometric transformation.
//    function projectPoint(x, y) {
//      var point = map.latLngToLayerPoint(new L.LatLng(y, x));
//      this.stream.point(point.x, point.y);
//    }
//  });

</script>

</body>
</html>